'use strict';

const _ = require('lodash');
const fs = require('fs');
const ajv = require('ajv');
const ajvKeywords = require('ajv-keywords');
const assert = require('assert');
const VError = require('verror').VError;
const xsenv = require('@sap/xsenv');
const https = require('https');
const UaaProvider = require('./credential-providers/UaaProvider');
const loggerUtils = require('./utils/logger-util');
const logger = loggerUtils.getLogger('/ServiceBroker/Server');
const validateCatalog = require('./validation/validate-catalog');
const SbssProvider = require('./credential-providers/SbssProvider');
const optionsSchema = require('./validation/schemas/sbf-api/options-schema');
const DummyProvider = require('./credential-providers/DummyProvider');

module.exports.loadConfig = function (options = {}) {
  options = _.cloneDeep(options);
  let envConfig = readEnvironmentConfig();
  let brokerConfig = _.defaults(options, envConfig, {
    hooks: {},
    catalog: './catalog.json',
    serviceConfig: {},
    autoCredentials: true,
    enableAuditLog: true,
    secureOutgoingConnections: true
  });

  https.globalAgent.options.ca = xsenv.loadCertificates();

  validateStartConfig(brokerConfig);
  if (_.isString(brokerConfig.catalog)) {
    brokerConfig.catalog = loadFromFile(brokerConfig.catalog);
  }

  validateCatalog(brokerConfig.catalog);
  validateServiceConfig(brokerConfig.serviceConfig, brokerConfig.catalog);

  brokerConfig.brokerCredentials &&
    (brokerConfig.brokerCredentials = toLowerCase(brokerConfig.brokerCredentials));

  brokerConfig.brokerCredentialsHash &&
    (brokerConfig.brokerCredentialsHash = toLowerCase(brokerConfig.brokerCredentialsHash));

  if (!brokerConfig.autoCredentials) {
    assert(!brokerConfig.credentialsProviderService,
      '"credentialsProviderService" is provided when "autoCredentials" is set to false');

    brokerConfig.hooks.onBind ||
      logger.warning('"autoCredentials" is set to false, onBind hook should be implemented!');
  }

  if (brokerConfig.enableAuditLog) {
    brokerConfig.auditCredentials = getAuditlogServiceCredentials();
  }

  // Additional properties
  brokerConfig.credentialsProvider = createCredentialsProvider(brokerConfig);
  mergeCatalogWithServiceConfig(brokerConfig.catalog, brokerConfig.serviceConfig);

  let html5AppsRepo = getHTML5AppsRepo();
  if (html5AppsRepo) {
    brokerConfig.html5AppsRepo = html5AppsRepo;
  }

  return brokerConfig;
};

function validateStartConfig(brokerConfig) {
  assert(brokerConfig.brokerCredentials || brokerConfig.brokerCredentialsHash,
    'Broker credentials should be provided either in plaintext or hashed');

  assert(!brokerConfig.brokerCredentials || !brokerConfig.brokerCredentialsHash,
    'Broker credentials should be provided either in plaintext or hashed, not both');

  let jsonValidator = new ajv();
  ajvKeywords(jsonValidator, ['typeof']);

  if (!jsonValidator.validate(optionsSchema, brokerConfig)) {
    throw new Error(jsonValidator.errorsText());
  }

  validateCredentials(brokerConfig.brokerCredentials);
}

function validateCredentials(brokerCredentials) {
  _.forOwn(brokerCredentials, (password, user) => {
    if (password.length < 15) {
      logger.warning(`Password for broker user ${user} is too short. ` +
        'For ISO/SOC compliance, the password should be at least 15 characters long.');
    }
  });
}

function mergeCatalogWithServiceConfig(catalog, envServiceConfig) {
  catalog.services.forEach((service) => {
    var serviceConfig = envServiceConfig[service.name];
    if (serviceConfig && serviceConfig.extend_catalog) {
      service = _.merge(service, serviceConfig.extend_catalog);
    }
  });
}

function loadFromFile(path) {
  logger.info('loading service catalog from file %s', path);

  let catalogContent = fs.readFileSync(path, 'utf8');
  try {
    return JSON.parse(catalogContent);
  } catch (e) {
    throw new VError(e, `Could not parse ${path}`);
  }
}

function loadJsonVar(envVar) {
  try {
    return process.env[envVar] && JSON.parse(process.env[envVar]);
  } catch (e) {
    throw new VError(e, `Invalid JSON value for environment variable ${envVar}`);
  }
}

function readEnvironmentConfig() {
  return {
    brokerCredentials: loadJsonVar('SBF_BROKER_CREDENTIALS'),
    brokerCredentialsHash: loadJsonVar('SBF_BROKER_CREDENTIALS_HASH'),
    serviceConfig: loadJsonVar('SBF_SERVICE_CONFIG'),
    credentialsProviderService: process.env['SBF_CREDENTIALS_PROVIDER_SERVICE'],
    sbssRestrictedUserService: process.env['SBF_SBSS_RESTRICTED_USER_SERVICE'],
    catalog: process.env['SBF_CATALOG_FILE'],
    catalogSuffix: process.env['SBF_CATALOG_SUFFIX'],
    secureOutgoingConnections: process.env['SBF_SECURE_OUTGOING_CONNECTIONS'] !== 'false',
    enableAuditLog: process.env['SBF_ENABLE_AUDITLOG'] !== 'false'
  };
}

function toLowerCase(credentials) {
  let newCredentials = _.mapKeys(credentials, (value, key) => key.toLowerCase());
  assert(_.size(newCredentials) === _.size(credentials),
    'Duplicate username found in broker credentials');
  return newCredentials;
}

function getAuditlogServiceCredentials() {
  let auditlog = findService({ label: 'auditlog-management', tag: 'auditlog-management' });
  assert(auditlog, 'No audit log service found');
  return auditlog.credentials;
}

function findService(query) {
  let matches = xsenv.filterCFServices(query);
  assert(matches.length < 2, 'Ambiguous services found: ' + matches.map(match => match.name).join(', '));
  return matches[0];
}

function findCredentialsService(credentialsProviderService) {
  let service;
  if (credentialsProviderService) {
    service = xsenv.filterCFServices(credentialsProviderService)[0];
    assert(service, `No service with name "${credentialsProviderService}" found`);
    return service;
  }
  service = findService({ label: 'hana', plan: 'sbss' }) || findService({ label: 'postgresql', tag: 'sbss' }) ||
    findService({ label: 'xsuaa', plan: 'broker' });
  assert(service, 'Could not find credentials service');
  logger.info(`Suitable credentials provider service found: "${service.name}"`);
  return service;
}

function checkHttpsConnection(url, secureOutgoingConnections) {
  if (/^https/i.test(url)) {
    return;
  }
  let message = 'Using unencrypted connection to XSUAA at ' + url;
  if (secureOutgoingConnections) {
    throw new Error(message);
  }
  logger.warning(message);
}

function checkSSLCertificate(certificate) {
  if (!certificate) {
    logger.warning('Using unencrypted SBSS database connection');
  }
}

function createCredentialsProvider(brokerConfig) {
  if (!brokerConfig.autoCredentials) {
    return new DummyProvider();
  }

  let bindingService = findCredentialsService(brokerConfig.credentialsProviderService);
  let credentials = bindingService.credentials;
  if (bindingService.label === 'xsuaa') {
    checkHttpsConnection(credentials.url, brokerConfig.secureOutgoingConnections);
    return new UaaProvider(credentials);
  } else {
    checkSSLCertificate(credentials.certificate);
    return createSbssProvider(brokerConfig, bindingService);
  }
}

function findSbssRestrictedUserService(brokerConfig) {
  if (brokerConfig.sbssRestrictedUserService) {
    return xsenv.filterCFServices(brokerConfig.sbssRestrictedUserService)[0];
  }
  const matches = xsenv.filterCFServices(service => service.credentials && service.credentials.tag === 'sbss-config');
  assert(matches.length < 2, 'Ambiguous services found: ' + matches.map(match => match.name).join(', '));
  return matches[0];
}

function getHTML5AppsRepo() {
  try {
    const credentials = xsenv.cfServiceCredentials({ tag: 'html5-apps-repo-rt' });
    return { 'html5-apps-repo': _.pick(credentials, ['app_host_id']) };
  } catch (e) {
    return null;
  }
}

function createSbssProvider(brokerConfig, bindingService) {
  if (bindingService.label === 'hana') {
    return new SbssProvider(bindingService.credentials);
  }
  const service = findSbssRestrictedUserService(brokerConfig);
  if (!service) {
    throw new Error('Using PostgreSQL SBSS requires restricted user credentials to ' +
        'be provided via user-provided service.');
  }
  logger.info(`Suitable PostgreSQL restricted user credentials found in service "${service.name}"`);

  const postrgesCredentials = _.extend({}, bindingService.credentials, {
    restrictedUser: service.credentials
  });
  return new SbssProvider(postrgesCredentials);
}

function checkPlanExists(serviceConfigExtension, servicePlans) {
  if (serviceConfigExtension) {
    for (let planName in serviceConfigExtension.per_plan) {
      assert(servicePlans.find(plan => plan.name === planName), `No matching plan with name ${planName}`);
    }
  }
}

function validateServiceConfig(serviceConfig, catalog) {
  for (let serviceName in serviceConfig) {
    let service = catalog.services.find(service => service.name === serviceName);
    assert(service, `No matching service in catalog with name ${serviceName} referenced in SBF_SERVICE_CONFIG`);
    checkPlanExists(serviceConfig[serviceName].extend_credentials, service.plans);
    checkPlanExists(serviceConfig[serviceName].extend_xssecurity, service.plans);
  }
}
