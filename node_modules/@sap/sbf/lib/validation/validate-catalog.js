'use strict';

const _ = require('lodash');
const ajv = require('ajv');
const VError = require('verror');
const catalogSchemaTemplate = require('./schemas/sbf-api/catalog-schema.json');

module.exports = validateCatalog;

function validateCatalog(catalog, options = {}) {
  let catalogSchema = _.cloneDeep(catalogSchemaTemplate);

  if (options.ignoreMissingIds) {
    catalogSchema.definitions.serviceObject.properties.id.minLength = 0;
    _.remove(catalogSchema.definitions.serviceObject.required, el => el === 'id');

    catalogSchema.definitions.planObject.properties.id.minLength = 0;
    _.remove(catalogSchema.definitions.planObject.required, el => el === 'id');
  }

  try {
    let jsonValidator = new ajv();

    if (!jsonValidator.validate(catalogSchema, catalog)) {
      throw new Error(jsonValidator.errorsText());
    }

    verifyUnique(catalog);
  }
  catch (err) {
    throw new VError(err, 'Service catalog is not valid');
  }
}

function verifyUnique(catalog) {
  const serviceAndPlanIDs = new Set();
  const serviceNames = new Set();

  for (let service of catalog.services) {
    service.id && addServiceIDToSet(service.id, serviceAndPlanIDs);
    addServiceNameToSet(service.name, serviceNames);

    const planNames = new Set();
    for (let plan of service.plans) {
      plan.id && addPlanIDToSet(plan.id, serviceAndPlanIDs);
      addPlanNameToSet(plan.name, planNames);
    }
  }
}

function addServiceIDToSet(id, set) {
  addItemToSet(id, set, 'catalog should have unique service and plan IDs');
}

function addServiceNameToSet(name, set) {
  addItemToSet(name, set, 'catalog should have unique service names');
}

function addPlanIDToSet(id, set) {
  addItemToSet(id, set, 'catalog should have unique service and plan IDs');
}

function addPlanNameToSet(name, set) {
  addItemToSet(name, set, 'catalog should have unique plan names per service');
}

function addItemToSet(item, set, errorMessage) {
  if (set.has(item)) {
    throw new Error(errorMessage);
  }

  set.add(item);
}
