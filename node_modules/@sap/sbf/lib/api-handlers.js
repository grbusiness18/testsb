'use strict';

const _ = require('lodash');
const async = require('async');
const { BadRequest, NotImplemented } = require('http-errors');
const loggify = require('./utils/logger-util').loggify;
const asyncUtil = require('./utils/async-util');
const configUtil = require('./utils/config-util');

module.exports.handleCatalog = function handleCatalog(req, res, next) {
  const tracer = req.loggingContext.getTracer(__filename);
  const SUFFIX = req.catalogSuffix;
  let catalog = addCatalogSuffixes(req.app._sbfConfig.catalog, SUFFIX);
  tracer.debug('service catalog: %j', catalog);
  res.send(catalog);
  next();
};

module.exports.handleProvision = function handleProvision(req, res, next) {
  let provisionSuccessful = false;
  const tracer = req.loggingContext.getTracer(__filename);
  const brokerConfig = req.app._sbfConfig;

  function onProvision(cb) {
    brokerConfig.credentialsProvider.provision(req, err => {
      provisionSuccessful = !err;
      cb(err);
    });
  }

  const sendReply = asyncUtil.optionalData((reply, cb) => {
    const statusCode = reply.async ? 202 : 201;
    tracer.debug(`Response from Service Broker to provision request with status ${statusCode} and body ${loggify(reply)}`);

    delete reply.async;
    res.status(statusCode).send(reply);
    cb();
  });

  async.waterfall([
    cb => auditlog(req, 'provisioned', cb),
    onProvision,
    cb => callHook('onProvision', req, cb),
    sendReply
  ], err => {
    err && provisionSuccessful && brokerConfig.credentialsProvider.deprovision(req, deprovisionErr => {
      tracer.debug('An error during provisioning occurred. Rolling back.');
      if (deprovisionErr) {
        return req.loggingContext.getLogger('/ServiceBroker/Server').error(deprovisionErr, 'Rollback failed');
      }
      tracer.debug('Rollback successful.');
    });
    return next(err);
  });
};

module.exports.handleDeprovision = function handleDeprovision(req, res, next) {
  const brokerConfig = req.app._sbfConfig;
  const tracer = req.loggingContext.getTracer(__filename);

  function onDeprovision(result, cb) {
    const callback = _.isFunction(result) ? result : err => cb(err, result);
    brokerConfig.credentialsProvider.deprovision(req, callback);
  }

  const sendReply = asyncUtil.optionalData((reply, cb) => {
    const statusCode = reply.async ? 202 : 200;
    tracer.debug(`Response from Service Broker to deprovision request with status ${statusCode} and body ${loggify(reply)}`);

    delete reply.async;
    res.status(statusCode).send(reply);
    cb();
  });

  async.waterfall([
    cb => auditlog(req, 'deprovisioned', cb),
    cb => callHook('onDeprovision', req, cb),
    onDeprovision,
    sendReply
  ], next);
};

module.exports.handleUpdate = function handleUpdate(req, res, next) {
  const tracer = req.loggingContext.getTracer(__filename);

  const sendReply = asyncUtil.optionalData((reply, cb) => {
    const statusCode = reply.async ? 202 : 200;
    tracer.debug(`Response from Service Broker to update request with status ${statusCode} and body ${loggify(reply)}`);

    delete reply.async;
    res.status(statusCode).send(reply);
    cb();
  });

  async.waterfall([
    cb => auditlog(req, 'updated', cb),
    cb => callHook('onUpdate', req, cb),
    sendReply
  ], next);
};

module.exports.handleLastOperation = function handleLastOperation(req, res, next) {
  const tracer = req.loggingContext.getTracer(__filename);

  const sendReply = asyncUtil.optionalData((reply, cb) => {
    if (!reply || !reply.state || !['in progress', 'succeeded', 'failed'].includes(reply.state)) {
      return cb(new Error('Invalid state provided by onLastOperation hook'));
    }

    tracer.debug(`Response from Service Broker to last operation request with status 200 and body ${loggify(reply)}`);
    res.status(200).send(reply);
    cb();
  });

  function callLastOperationHook(cb) {
    const onLastOperation = req.app._sbfConfig.hooks.onLastOperation;
    if (!_.isFunction(onLastOperation)) {
      return cb(new NotImplemented('onLastOperation not implemented!'));
    }

    callClientHook(onLastOperation, 'onLastOperation', req, cb);
  }

  async.waterfall([
    cb => auditlog(req, 'Last operation was called', cb),
    callLastOperationHook,
    sendReply
  ], next);
};

module.exports.handleBind = function handleBind(req, res, next) {
  const brokerConfig = req.app._sbfConfig;
  const tracer = req.loggingContext.getTracer(__filename);

  if (!checkBindable(brokerConfig.catalog, req.brokerContext)) {
    return next(new BadRequest('Service or plan not bindable'));
  }

  const onBind = cb => {
    brokerConfig.credentialsProvider.bind(req, (err, credentials) => {
      if (err) { return cb(err); }
      req.brokerContext.generatedCredentials  = credentials;
      cb();
    });
  };

  const sendReply = asyncUtil.optionalData((reply, cb) => {
    let serviceId = req.brokerContext.service_id;
    let bindingConfig = configUtil.extractBindingConfig(brokerConfig.catalog,
      brokerConfig.serviceConfig, serviceId, req.brokerContext.plan_id);
    let businessServiceData = buildBusinessServiceData(brokerConfig, serviceId);
    reply.credentials = _.merge(bindingConfig, businessServiceData, req.brokerContext.generatedCredentials, reply.credentials);

    const statusCode = 201;
    tracer.debug(`Response from Service Broker to bind request with status ${statusCode} and body ${loggify(reply)}`);

    res.status(statusCode).send(reply);
    cb();
  });

  async.waterfall([
    cb => auditlog(req, 'bound', cb),
    onBind,
    cb => callHook('onBind', req, cb),
    sendReply
  ], err => {
    err && req.brokerContext.generatedCredentials && brokerConfig.credentialsProvider.unbind(req, unbindErr => {
      tracer.debug('An error during binding occurred. Rolling back.');
      if (unbindErr) {
        return req.loggingContext.getLogger('/ServiceBroker/Server').error(unbindErr, 'Rollback failed');
      }
      tracer.debug('Rollback successful.');
    });
    return next(err);
  });
};

module.exports.handleUnbind = function handleUnbind(req, res, next) {
  let brokerConfig = req.app._sbfConfig;
  const tracer = req.loggingContext.getTracer(__filename);

  if (!checkBindable(brokerConfig.catalog, req.brokerContext)) {
    return next(new BadRequest('Service or plan not bindable'));
  }

  function onUnbind(result, cb) {
    const callback = _.isFunction(result) ? result : err => cb(err, result);
    brokerConfig.credentialsProvider.unbind(req, callback);
  }

  const sendReply = asyncUtil.optionalData((reply, cb) => {
    tracer.debug(`Response from Service Broker to unbind request with status 200 and body ${loggify(reply)}`);
    res.status(200).send(reply);
    cb();
  });

  async.waterfall([
    cb => auditlog(req, 'unbound', cb),
    cb => callHook('onUnbind', req, cb),
    onUnbind,
    sendReply
  ], next);
};

function callHook(hookName, req, cb) {
  const hook = req.app._sbfConfig.hooks[hookName];
  if (!_.isFunction(hook)) { return cb(); }
  callClientHook(hook, hookName, req, cb);
}

function callClientHook(hook, hookName, req, cb) {
  const tracer = req.loggingContext.getTracer(__filename);
  const params = _.cloneDeep(req.brokerContext);
  params.req = req;
  tracer.debug(`${hookName} hook called with: ${loggify(params)}`);
  hook(params, cb);
}

function checkBindable(catalog, brokerContext) {
  const serviceConfig = configUtil.getService(catalog, brokerContext.service_id);
  const planConfig = configUtil.getServicePlan(serviceConfig, brokerContext.plan_id);

  return serviceConfig.bindable && planConfig.bindable !== false;
}

function addCatalogSuffixes(catalog, suffix) {
  catalog = _.cloneDeep(catalog);
  if (suffix) {
    for (let service of catalog.services) {
      service.id = configUtil.addSuffix(service.id, suffix);
      service.name = configUtil.addSuffix(service.name, suffix);
      for (let plan of service.plans) {
        plan.id = configUtil.addSuffix(plan.id, suffix);
      }
    }
  }

  return catalog;
}

function auditlog(req, operation, cb) {
  if (!req.app._sbfConfig.enableAuditLog) {
    return cb();
  }
  const serviceId = req.brokerContext.service_id;
  const planId = req.brokerContext.plan_id;
  const message = `Service ${serviceId} with plan ${planId} is being ${operation}`;
  let ip = req.headers['x-forwarded-for'] || req.connection.remoteAddress;
  ip = ip.split(',')[0];
  const identity = req.originatingIdentity || {};
  let user = identity.user_id || identity.uid || identity.username || req.brokerUser;
  req.app.audit.logSecurityEvent(message, user, ip, cb);
}

function buildBusinessServiceData(brokerConfig, serviceId) {
  const businessServiceMetadata = getBusinessServiceMetadata(brokerConfig.catalog, serviceId);
  return _.extend({}, businessServiceMetadata, brokerConfig.html5AppsRepo);
}

function getBusinessServiceMetadata(catalog, serviceId) {
  const service = configUtil.getService(catalog, serviceId);
  const sapServiceMetadata = (service.metadata && service.metadata.sapservice) || {};
  return _.pick(sapServiceMetadata, ['sap.cloud.service', 'saasregistryenabled']);
}
