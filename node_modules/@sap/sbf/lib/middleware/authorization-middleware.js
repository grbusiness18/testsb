'use strict';

const crypto = require('crypto');
const parseAuthHeader = require('basic-auth');
const Unauthorized = require('http-errors').Unauthorized;

module.exports = function authorization(req, res, next) {
  const providedCredentials = parseAuthHeader(req);
  const trace = req.loggingContext.getTracer(__filename);

  let authorized;

  if (!providedCredentials) {
    authorized = false;
    trace.debug('No credentials provided');
  } else {
    authorized = req.app._sbfConfig.brokerCredentials ?
      verifyPlainTextCredentials(providedCredentials, req.app._sbfConfig.brokerCredentials, trace) :
      verifyHashedCredentials(providedCredentials, req.app._sbfConfig.brokerCredentialsHash, trace);
  }

  res.header('WWW-Authenticate', 'Basic realm="Service Broker API"');
  if (authorized) {
    req.brokerUser = providedCredentials.name;
    next();
  } else {
    if (req.app._sbfConfig.enableAuditLog && providedCredentials) {
      auditFailedLogin(providedCredentials, req, next);
    } else {
      next(new Unauthorized());
    }
  }
};

function auditFailedLogin(providedCredentials, req, next) {
  const audit = req.app.audit;
  let ip = req.headers['x-forwarded-for'] || req.connection.remoteAddress;
  ip = ip.split(',')[0];
  audit.logSecurityEvent('Failed login attempt', providedCredentials ? providedCredentials.name : '', ip, err => {
    if (err) {
      return next(err);
    }
    next(new Unauthorized());
  });
}

function verifyPlainTextCredentials(providedCredentials, expectedCredentials, trace) {
  const expectedPassword = expectedCredentials[providedCredentials.name.toLowerCase()];
  let authorized = false;

  if (expectedPassword) {
    let expectedPasswordBuffer = Buffer.from(expectedPassword);
    let providedPasswordBuffer = Buffer.from(providedCredentials.pass);

    if (expectedPassword.length !== providedCredentials.pass.length) {
      // make sure the time is constant even in case of different length passwords
      crypto.timingSafeEqual(expectedPasswordBuffer, expectedPasswordBuffer);
    } else {
      authorized = crypto.timingSafeEqual(expectedPasswordBuffer, providedPasswordBuffer);
    }
  }

  authorized || trace.debug('Plain text credentials do not match');
  return authorized;
}

function verifyHashedCredentials(providedCredentials, expectedCredentials, trace) {
  const expectedPasswordComponents = expectedCredentials[providedCredentials.name.toLowerCase()];
  let authorized = false;

  if (expectedPasswordComponents) {
    let [algo, salt, expectedDigest] = expectedPasswordComponents.split(':');
    expectedDigest = Buffer.from(expectedDigest, 'base64');

    const providedDigest = crypto
      .createHash(algo)
      .update(Buffer.from(salt, 'base64'))
      .update(providedCredentials.pass)
      .digest();

    authorized =
      providedDigest.length === expectedDigest.length &&
      crypto.timingSafeEqual(providedDigest, expectedDigest);
  }

  authorized || trace.debug('Hashed credentials do not match');
  return authorized;
}
