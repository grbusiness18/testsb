'use strict';

const _ = require('lodash');
const assert = require('assert');
const debug = require('debug')('sbss');
const pg = require('pg');
const VError = require('verror');

const RUSER_NAME = 'restricted-dbuser-name';
const RUSER_PASS = 'restricted-dbuser-password';

module.exports = class PostgresClient {
  constructor(options) {
    assert(options && typeof options === 'object', 'options should be an object');
    assert(options.hostname, 'missing hostname property');
    assert(options.port, 'missing port property');
    assert(options.username, 'missing username property');
    assert(options.password, 'missing password property');
    assert(options.dbname, 'missing dbname property');
    debug('Using PostgreSQL %s@%s:%s/%s',
      options.username, options.hostname, options.port, options.dbname);
    if (options.restrictedUser) {
      assert(options.restrictedUser[RUSER_NAME], 'missing restricted user name');
      assert(options.restrictedUser[RUSER_PASS], 'missing restricted user password');
      debug('Using restricted DB user %s', options.restrictedUser[RUSER_NAME]);
    }
    this._options = options;
    this._pool = new pg.Pool(this._createRestrictedUserOptions());
  }

  _call(procName, params, callback) {
    let proc = 'SYS_XS_SBSS.' + procName;
    let paramString = params.map((v, i) => `$${i + 1}`).join(',');
    let sql = `select * from ${proc}(${paramString})`;
    debug(sql);
    this._pool.query(sql, params, (err, result) => {
      if (err) {
        debug(err);
        return callback(new VError(err, `Error calling stored procedure ${proc}`));
      }
      callback(null, result.rows[0]);
    });
  }

  createCredentials(options, callback) {
    assert(options && typeof options === 'object', 'options should be an object');

    this._detectSbssVersion((err, version) => {
      if (err) {
        return callback(err);
      }

      if (version === 1.1 || Object.keys(options).length === 2) {
        this._createCredentialsV1_1(options, callback);
      } else if (version === 1.2 || !options.hasOwnProperty('subaccountId')) {
        this._createCredentialsV1_2(options, callback);
      } else {
        this._createCredentialsV1_3(options, callback);
      }
    });
  }

  _createCredentialsV1_1(options, callback) { // eslint-disable-line camelcase
    assert(options.instanceId && _.isString(options.instanceId), 'instanceId should be a non-empty string');
    assert(options.bindingId && _.isString(options.bindingId), 'bindingId should be a non-empty string');
    assert(_.isFunction(callback), 'callback should be a function');

    this._call('CREATE_BINDING_CREDENTIAL', [options.instanceId, options.bindingId], (err, result) => {
      if (err) { return callback(err); }
      callback(null, {
        username: result.service_user_name,
        password: result.service_user_password
      });
    });
  }

  _createCredentialsV1_2(options, callback) { // eslint-disable-line camelcase
    assert(options.instanceId && _.isString(options.instanceId), 'instanceId should be a non-empty string');
    assert(options.bindingId && _.isString(options.bindingId), 'bindingId should be a non-empty string');
    assert(options.serviceId && _.isString(options.serviceId), 'serviceId should be a non-empty string');
    assert(options.planId && _.isString(options.planId), 'planId should be a non-empty string');
    assert(!options.appGuid || _.isString(options.appGuid), 'appGuid should be a non-empty string');
    assert(_.isFunction(callback), 'callback should be a function');

    this._call('CREATE_EXTENDED_BINDING_CREDENTIAL', [
      options.instanceId,
      options.bindingId,
      options.serviceId,
      options.planId,
      options.appGuid || 'N/A'
    ], (err, result) => {
      if (err) { return callback(err); }
      callback(null, {
        username: result.service_user_name,
        password: result.service_user_password
      });
    });
  }

  _createCredentialsV1_3(options, callback) { // eslint-disable-line camelcase
    assert(options.instanceId && _.isString(options.instanceId), 'instanceId should be a non-empty string');
    assert(options.bindingId && _.isString(options.bindingId), 'bindingId should be a non-empty string');
    assert(options.serviceId && _.isString(options.serviceId), 'serviceId should be a non-empty string');
    assert(options.planId && _.isString(options.planId), 'planId should be a non-empty string');
    assert(!options.appGuid || _.isString(options.appGuid), 'appGuid should be a non-empty string');
    assert(options.subaccountId && _.isString(options.subaccountId), 'subaccountId should be a non-empty string');
    assert(_.isFunction(callback), 'callback should be a function');

    this._call('CREATE_BINDING_CREDENTIAL_V2', [
      options.instanceId,
      options.bindingId,
      options.serviceId,
      options.planId,
      options.appGuid || 'N/A',
      options.subaccountId
    ], (err, result) => {
      if (err) { return callback(err); }
      callback(null, {
        username: result.service_user_name,
        password: result.service_user_password
      });
    });
  }

  deleteCredentials(instanceId, bindingId, callback) {
    assert(instanceId && _.isString(instanceId), 'instanceId should be a non-empty string');
    assert(bindingId && _.isString(bindingId), 'bindingId should be a non-empty string');
    assert(_.isFunction(callback), 'callback should be a function');

    this._call('DROP_BINDING_CREDENTIAL', [instanceId, bindingId], (err, result) => {
      if (err) { return callback(err); }
      callback(null, {
        deletedCredentials: result.p_deleted_binding_credentials
      });
    });
  }

  deleteAllInstanceCredentials(instanceId, callback) {
    assert(instanceId && _.isString(instanceId), 'instanceId should be a non-empty string');
    assert(_.isFunction(callback), 'callback should be a function');

    this._call('DROP_ALL_BINDING_CREDENTIALS', [instanceId], (err, result) => {
      if (err) { return callback(err); }
      callback(null, {
        deletedCredentials: result.p_deleted_binding_credentials
      });
    });
  }

  validateCredentials(username, password, callback) {
    assert(username && _.isString(username), 'username should be a non-empty string');
    assert(password && _.isString(password), 'password should be a non-empty string');
    assert(_.isFunction(callback), 'callback should be a function');


    this._detectSbssVersion((err, version) => {
      if (err) {
        return callback(err);
      }

      if (version === 1.1) {
        this._validateCredentialsV1_1(username, password, callback);
      } else if (version === 1.2) {
        this._validateCredentialsV1_2(username, password, callback);
      } else {
        this._validateCredentialsV1_3(username, password, callback);
      }
    });

  }

  _validateCredentialsV1_1(username, password, callback) { // eslint-disable-line camelcase
    this._call('VALIDATE_BINDING_CREDENTIAL', [username, password], (err, result) => {
      if (err) { return callback(err); }
      if (result.instance_id === null && result.binding_id === null) {
        return callback(new VError('authentication failed'));
      }
      callback(null, {
        instanceId: result.instance_id,
        bindingId: result.binding_id
      });
    });
  }

  _validateCredentialsV1_2(username, password, callback) { // eslint-disable-line camelcase
    this._call('VALIDATE_EXTENDED_BINDING_CREDENTIAL', [username, password], (err, result) => {
      if (err) { return callback(err); }
      if (result.instance_id === null && result.binding_id === null) {
        return callback(new VError('authentication failed'));
      }
      callback(null, {
        instanceId: result.instance_id,
        bindingId: result.binding_id,
        serviceId: result.service_id,
        planId: result.plan_id,
        appGuid: result.app_guid
      });
    });
  }

  _validateCredentialsV1_3(username, password, callback) { // eslint-disable-line camelcase
    this._call('VALIDATE_BINDING_CREDENTIAL_V2', [username, password], (err, result) => {
      if (err) { return callback(err); }
      if (result.instance_id === null && result.binding_id === null) {
        return callback(new VError('authentication failed'));
      }
      callback(null, {
        instanceId: result.instance_id,
        bindingId: result.binding_id,
        serviceId: result.service_id,
        planId: result.plan_id,
        appGuid: result.app_guid,
        subaccountId: result.sub_account_id
      });
    });
  }

  _createRestrictedUserOptions() {
    const options = this._createPowerUserOptions();
    const restrictedUser = this._options.restrictedUser;
    if (restrictedUser) {
      _.extend(options, {
        user: restrictedUser[RUSER_NAME],
        password: restrictedUser[RUSER_PASS]
      });
    }
    return options;
  }

  _createPowerUserOptions() {
    return {
      host: this._options.hostname,
      port: this._options.port,
      user: this._options.username,
      password: this._options.password,
      database: this._options.dbname
    };
  }

  _detectSbssVersion(callback) {
    if (this._sbssVersion) {
      return callback(null, this._sbssVersion);
    }
    const client = new pg.Client(this._createPowerUserOptions());

    const sql = 'select version from SYS_XS_SBSS.schema_version where success=true order by installed_rank desc limit 1';
    debug('Execute: %s', sql);
    const self = this;

    function readResultSet(err, result) {
      if (err) {
        debug(err);
        return callback(new VError(err, `Could not determine SBSS version: Error executing ${sql}`));
      }
      if (result.rows.length === 0) {
        return callback(new Error(`Could not determine SBSS version: ${sql} returned 0 rows`));
      }

      const sbssVersion = parseFloat(result.rows[0].version);
      if (sbssVersion < 1.1) {
        return callback(new Error(`SBSS version ${sbssVersion} is not supported. At least version 1.1 is required.`));
      }

      self._sbssVersion = sbssVersion;
      debug('Found SBSS version %s in schema_version', self._sbssVersion);
      callback(null, self._sbssVersion);
    }

    client.connect((err) => {
      if (err) {
        debug(err);
        return callback(new VError(err, 'Could not determine SBSS version: Connection error'));
      }
      client.query(sql, readResultSet);
    });
  }
};
