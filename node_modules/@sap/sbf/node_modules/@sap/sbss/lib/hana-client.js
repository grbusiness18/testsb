'use strict';

const _ = require('lodash');
const assert = require('assert');
const debug = require('debug')('sbss');
const VError = require('verror');

const ERR_SQL_INV_TABLE = 259;
const ERR_SQLSCRIPT_NO_DATA_FOUND = 1299;
const ERR_USER_DEFINED_ERROR = 10001;
const ERR_AUTHENTICATION_FAILED = 10;

let hdbext = null;

module.exports = class HanaClient {
  constructor(options) {
    assert(options && typeof options === 'object', 'options should be an object');
    this._options = _.cloneDeep(options);
    hdbext = require('@sap/hdbext');
  }

  _call(procName, params, callback) {
    function callProc(client, cb) {
      debug('Calling stored procedure SYS_XS_SBSS.%s', procName);
      hdbext.loadProcedure(client, 'SYS_XS_SBSS', procName, (err, sp) => {
        let errorMessage = `Error calling stored procedure SYS_XS_SBSS.${procName}`;
        if (err) {
          debug(err);
          return cb(new VError(wrapError(err), errorMessage));
        }
        sp(params, (err, result, errResult) => {
          if (err) {
            debug(err);
            return cb(new VError(wrapError(err), errorMessage));
          }
          if (errResult && errResult.length) {
            debug(errResult);
            // SBSS complains if there are no credentials to delete
            // don't treat this as error
            if (!result || result.DELETED_BINDING_CREDENTIALS !== 0) {
              var message = errResult[0][':2'] || JSON.stringify(errResult);
              return cb(new Error(errorMessage + ': ' + message));
            }
          }
          cb(null, result);
        });
      });
    }
    this._dbExecute(callProc, callback);
  }

  createCredentials(options, callback) {
    assert(options && typeof options === 'object', 'options should be an object');

    this._detectSbssVersion((err, version) => {
      if (err) {
        return callback(err);
      }

      if (version === 5 || Object.keys(options).length === 2) {
        this._createCredentialsV5(options, callback);
      } else {
        this._createCredentialsV6(options, callback);
      }
    });
  }

  _createCredentialsV6(options, callback) {
    assert(options.instanceId && _.isString(options.instanceId), 'instanceId should be a non-empty string');
    assert(options.bindingId && _.isString(options.bindingId), 'bindingId should be a non-empty string');
    assert(options.serviceId && _.isString(options.serviceId), 'serviceId should be a non-empty string');
    assert(options.planId && _.isString(options.planId), 'planId should be a non-empty string');
    assert(!options.appGuid || _.isString(options.appGuid), 'appGuid should be a non-empty string');
    assert(_.isFunction(callback), 'callback should be a function');

    let params = {
      INSTANCE_ID: options.instanceId,
      BINDING_ID: options.bindingId,
      SERVICE_ID: options.serviceId,
      PLAN_ID: options.planId,
      APP_GUID: options.appGuid || 'N/A'
    };
    this._call('CREATE_EXTENDED_BINDING_CREDENTIAL', params, (err, result) => {
      if (err) { return callback(err); }
      callback(null, {
        username: result.SERVICE_USER_NAME,
        password: result.SERVICE_USER_PASSWORD
      });
    });
  }

  _createCredentialsV5(options, callback) {
    assert(options.instanceId && _.isString(options.instanceId), 'instanceId should be a non-empty string');
    assert(options.bindingId && _.isString(options.bindingId), 'bindingId should be a non-empty string');
    assert(_.isFunction(callback), 'callback should be a function');

    let params = {
      INSTANCE_ID: options.instanceId,
      BINDING_ID: options.bindingId,
      DISABLE_CREDENTIAL_VALIDATION: 0
    };
    this._call('CREATE_BINDING_CREDENTIAL', params, (err, result) => {
      if (err) { return callback(err); }
      callback(null, {
        username: result.SERVICE_USER_NAME,
        password: result.SERVICE_USER_PASSWORD
      });
    });
  }

  deleteCredentials(instanceId, bindingId, callback) {
    assert(instanceId && _.isString(instanceId), 'instanceId should be a non-empty string');
    assert(bindingId && _.isString(bindingId), 'bindingId should be a non-empty string');
    assert(_.isFunction(callback), 'callback should be a function');

    let params = {
      INSTANCE_ID: instanceId,
      BINDING_ID: bindingId,
      FORCE_DELETE: 1
    };
    this._call('DROP_BINDING_CREDENTIAL', params, (err, result) => {
      if (err) { return callback(err); }
      callback(null, {
        deletedCredentials: result.DELETED_BINDING_CREDENTIALS
      });
    });
  }

  deleteAllInstanceCredentials(instanceId, callback) {
    assert(instanceId && _.isString(instanceId), 'instanceId should be a non-empty string');
    assert(_.isFunction(callback), 'callback should be a function');

    let params = {
      INSTANCE_ID: instanceId,
      FORCE_DELETE: 1
    };
    this._call('DROP_ALL_BINDING_CREDENTIALS', params, (err, result) => {
      if (err) { return callback(err); }
      callback(null, {
        deletedCredentials: result.DELETED_BINDING_CREDENTIALS
      });
    });
  }

  validateCredentials(username, password, callback) {
    assert(username && _.isString(username), 'username should be a non-empty string');
    assert(password && _.isString(password), 'password should be a non-empty string');
    assert(_.isFunction(callback), 'callback should be a function');

    this._detectSbssVersion((err, version) => {
      if (err) {
        return callback(err);
      }

      if (version === 5) {
        this._validateCredentialsV5(username, password, callback);
      } else {
        this._validateCredentialsV6(username, password, callback);
      }
    });
  }

  _validateCredentialsV5(username, password, callback) {
    function fetchBindings(client, cb) {
      client.exec('select * from SYS_XS_SBSS.MYBINDINGS', function (err, rows) {
        if (err) { return cb(wrapError(err)); }
        if (rows.length !== 1) {
          return cb(new Error(`SYS_XS_SBSS.MYBINDINGS returned ${rows.length} rows`));
        }
        cb(null, {
          instanceId: rows[0].INSTANCE_ID,
          bindingId: rows[0].BINDING_ID
        });
      });
    }

    // connect with given user and password to validate them
    let options = _.defaults({ user: username, password }, this._options);
    execute(options, fetchBindings, (err, result) => {
      if (err && err.code === ERR_AUTHENTICATION_FAILED) {
        return callback(new VError(err, 'authentication failed'));
      }
      callback(err, result);
    });
  }

  _validateCredentialsV6(username, password, callback) {
    let params = {
      SERVICE_USER_NAME: username,
      SERVICE_USER_PASSWORD: password
    };
    this._call('VALIDATE_EXTENDED_BINDING_CREDENTIAL', params, (err, result) => {
      if (err) {
        const code = err.cause && err.cause().code;
        if (code === ERR_AUTHENTICATION_FAILED || code === ERR_SQLSCRIPT_NO_DATA_FOUND ||
          code === ERR_USER_DEFINED_ERROR) {
          return callback(new VError(err, 'authentication failed'));
        }
        return callback(err);
      }
      callback(null, {
        instanceId: result.INSTANCE_ID,
        bindingId: result.BINDING_ID,
        serviceId: result.SERVICE_ID,
        planId: result.PLAN_ID,
        appGuid: result.APP_GUID
      });
    });
  }

  _detectSbssVersion(cb) {
    if (this._sbssVersion) {
      return cb(null, this._sbssVersion);
    }

    function selectCurrentVersion(client, cb) {
      const sql = 'select * from SYS_XS_SBSS.CURRENTVERSION';
      debug('Execute: %s', sql);
      client.exec(sql, function (err, rows) {
        if (err) {
          if (err.code === ERR_SQL_INV_TABLE) {
            debug('CURRENTVERSION does not exist, assuming SBSS version 5');
            return cb(null, 5);
          }
          return cb(wrapError(err));
        }
        if (rows.length !== 1) {
          return cb(new Error(`SYS_XS_SBSS.CURRENTVERSION returned ${rows.length} rows`));
        }
        debug('Found SBSS version %s in CURRENTVERSION', rows[0].VERSION);
        cb(null, rows[0].VERSION);
      });
    }

    this._dbExecute(selectCurrentVersion, (err, version) => {
      if (!err) {
        this._sbssVersion = version;
      }
      cb(err, version);
    });
  }

  _dbExecute(exec, cb) {
    const options = _.extend({ pooling: true }, this._options);
    execute(options, exec, cb);
  }
};

function execute(options, exec, cb) {
  hdbext.createConnection(options, (err, client) => {
    if (err) { return cb(wrapError(err)); }
    exec(client, (err, result) => {
      cb(err, result);
      backgroundClose(client);
    });
  });
}

function wrapError(err) {
  // error objects returned from @sap/hana-client are not
  // instances of Error, so we need to wrap them for VError and application code

  let e = new Error(err.message);
  ['code', 'sqlState'].forEach(prop => {
    if (err.hasOwnProperty(prop)) {
      e[prop] = err[prop];
    }
  });
  return e;
}

function backgroundClose(client) {
  client.close(err => {
    if (err) {
      debug('Error during client.close:', err);
    }
  });
}
