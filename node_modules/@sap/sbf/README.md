# @sap/sbf
A Node.js framework to create a service broker in SAP Cloud Platform

The Service Broker Framework (SBF) implements the [Open Service Broker API](https://www.openservicebrokerapi.org/).
It can be used in the Cloud Foundry environment of SAP Cloud Platform or on-premise in SAP HANA XS advanced model.

**Note**: SBF rejects requests for which the `X-Broker-API-Version` header is not set or its value is outside the supported interval [2.4, 3).

SBF can generate service credentials for these authentication mechanisms:
* Basic authentication for technical users (via SBSS)
* OAuth2 authentication with JSON Web Tokens (JWT) (via XSUAA _broker_ plan)
  * Named user via *user_token* flow
  * Technical user via *client_credentials* flow

After adding the necessary configuration, the SBF can be started directly as a service broker.
If necessary, it can be extended with custom JavaScript code.

All the information here is valid also for XS advanced, unless explicitly stated otherwise.
In the shell commands below replace `cf` with `xs` when working on XS advanced.

**Table of contents**

<!-- toc -->

- [Usage](#usage)
  * [Create a simple service broker](#create-a-simple-service-broker)
    + [Prerequisites](#prerequisites)
    + [Create a Node.js application](#create-a-nodejs-application)
    + [Add the Service Broker Framework](#add-the-service-broker-framework)
    + [Add @sap/hdbext package](#add-saphdbext-package)
    + [Add a start command](#add-a-start-command)
    + [Specify required Node.js version](#specify-required-nodejs-version)
    + [Create the service catalog](#create-the-service-catalog)
    + [Create SBSS service instance](#create-sbss-service-instance)
    + [Create Audit log service instance](#create-audit-log-service-instance)
    + [Create application manifest](#create-application-manifest)
    + [Push the broker application](#push-the-broker-application)
    + [Register the service broker](#register-the-service-broker)
    + [Use the service broker](#use-the-service-broker)
  * [Extend the service broker](#extend-the-service-broker)
  * [Asynchronous broker operations](#asynchronous-broker-operations)
  * [Service broker as middleware](#service-broker-as-middleware)
  * [Custom parameters](#custom-parameters)
    + [Create service with custom parameters](#create-service-with-custom-parameters)
    + [Update service with custom parameters](#update-service-with-custom-parameters)
    + [Bind service with custom parameters](#bind-service-with-custom-parameters)
  * [Credentials providers](#credentials-providers)
    + [SBSS](#sbss)
      - [SBSS on SAP HANA](#sbss-on-sap-hana)
      - [SBSS on PostgreSQL](#sbss-on-postgresql)
    + [XSUAA](#xsuaa)
  * [Unique service broker](#unique-service-broker)
  * [Secure outgoing connections](#secure-outgoing-connections)
  * [Stateless](#stateless)
  * [Memory usage](#memory-usage)
  * [User Interface](#user-interface)
  * [Security](#security)
    + [Password rotation](#password-rotation)
    + [HTTPS](#https)
  * [Audit logging](#audit-logging)
- [Reference](#reference)
  * [Class: ServiceBroker](#class-servicebroker)
    + [new ServiceBroker([options])](#new-servicebrokeroptions)
    + [ServiceBroker.start()](#servicebrokerstart)
    + [ServiceBroker.app](#servicebrokerapp)
    + [ServiceBroker.callXsuaa(req, options, callback)](#servicebrokercallxsuaareq-options-callback)
    + [(static) ServiceBroker.createCredentialsProvider(credentials)](#static-servicebrokercreatecredentialsprovidercredentials)
  * [Service Broker Credentials](#service-broker-credentials)
  * [Service Broker Hashed Credentials](#service-broker-hashed-credentials)
  * [Service Catalog](#service-catalog)
  * [Additional Service Configuration](#additional-service-configuration)
  * [Automatic Credentials Generation](#automatic-credentials-generation)
  * [Credentials Provider Service](#credentials-provider-service)
  * [Business Service Support](#business-service-support)
  * [Hooks](#hooks)
    + [`onProvision(params, callback)`](#onprovisionparams-callback)
    + [`onUpdate(params, callback)`](#onupdateparams-callback)
    + [`onDeprovision(params, callback)`](#ondeprovisionparams-callback)
    + [`onLastOperation(params, callback)`](#onlastoperationparams-callback)
    + [`onBind(params, callback)`](#onbindparams-callback)
    + [`onUnbind(params, callback)`](#onunbindparams-callback)
    + [`params` details](#params-details)
      - [`req`](#req)
    + [Error handling](#error-handling)
  * [Environment variables](#environment-variables)
  * [`gen-catalog-ids`](#gen-catalog-ids)
  * [`hash-broker-password`](#hash-broker-password)
- [Troubleshooting](#troubleshooting)
  * [Increase the log level](#increase-the-log-level)
  * [@sap/sbf not found](#sapsbf-not-found)
  * [Cannot execute start-broker script](#cannot-execute-start-broker-script)
  * [Create service fails with "Client already exists"](#create-service-fails-with-client-already-exists)

<!-- tocstop -->

## Usage

Examples demonstrating the usage and consumption of the service broker framework can be found in the [examples](examples/) directory.

### Create a simple service broker
For simple use cases, you don't need to write any JavaScript code. You can start this package directly providing it the necessary configuration.

The following sections describe the steps to create a simple service broker application using this framework.

#### Prerequisites
You will need the following:
- [Node.js](https://nodejs.org) v6 or later
- Cloud Foundry [CLI](https://github.com/cloudfoundry/cli#downloads)
- Access to a Cloud Foundry installation where you can login via CLI and push applications

#### Create a Node.js application
Create a new directory and run this command inside it:
```sh
npm init
```
You will have to answer several questions. Upon completion, this command will create a _package.json_ file in the current directory. The presence of this file, tells Cloud Foundry that this is a Node.js application.

#### Add the Service Broker Framework
Download the _@sap/sbf_ package and add it to your service broker by executing the following command:
```sh
npm install --save @sap/sbf
```

#### Add @sap/hdbext package
Since version 4 of _@sap/sbf_, broker applications that use SBSS on HANA need to explicitly specify
a dependency to the _@sap/hdbext_ package.

Download the _@sap/hdbext_ package and add it to your service broker by executing the following command:
```sh
npm install --save @sap/hdbext
```

#### Add a start command
Edit the _package.json_ file and add a `start` command in section `scripts`:
```json
{
  "scripts": {
    "start": "start-broker"
  }
}
```

#### Specify required Node.js version
Add the following property in the _package.json_ file to tell Cloud Foundry that the service broker requires Node.js v6:
```json
  "engines": {
    "node": "^6"
  }
```

#### Create the service catalog
The service catalog describes the services offered by this service broker.
It is defined in JSON format as described in [Cloud Foundry documentation](https://docs.cloudfoundry.org/services/api.html#catalog-management).

Create a file called _catalog.json_ in the current directory and describe inside the service catalog.
Here is an example:
```json
{
  "services": [{
    "name": "my-service",
    "description": "A simple service",
    "bindable": true,
    "plans": [{
      "name": "my-plan",
      "description": "The only plan"
    }]
  }]
}
```

Execute the following command to generate unique IDs for the services and their plans in the _catalog.json_ file:
```sh
node_modules/.bin/gen-catalog-ids
```

#### Create SBSS service instance
The service broker can use different services to generate and store credentials used later on by applications to access your reusable service. In this example we will use the SBSS credentials provider service.

Create an SBSS service instance with the following command:
```sh
cf create-service hana sbss my-sbss
```
Here `my-sbss` is the service instance name. You can use an arbitrary name here. Just use the same name in the following commands.

Here SBSS is used on HANA. You can also use SBSS on PostgreSQL in a similar way.
Check the SBSS documentation how to deploy it on PostgreSQL.

**Note:** If you use SBSS on PostgreSQL, you must add `sbss` tag to its service instance.
You can do this via `cf create-service` or `cf update-service` commands.

#### Create Audit log service instance
The service broker is configured by default to audit log every operation. It needs information to connect to the Audit log service.

Create Audit log service with the following command:
```sh
cf create-service auditlog standard broker-audit
```

#### Create application manifest
The service broker can be deployed on Cloud Foundry as a regular application.
An easy way to do that is via an [application manifest](https://docs.cloudfoundry.org/devguide/deploy-apps/manifest.html).
Create a _manifest.yml_ file in the current directory with content like this:
```yaml
---
applications:
  - name: my-broker
    memory: 128M
    services:
      - my-sbss
      - broker-audit
    env:
      SBF_BROKER_CREDENTIALS: >
        {
          "broker-user": "broker-password"
        }
      SBF_SERVICE_CONFIG: >
        {
          "my-service": {
            "extend_credentials": {
              "shared": {
                "uri": "https://my-service.example.com"
              }
            }
          }
        }
```

Here `my-broker` is the broker application name. You can use an arbitrary name here.

Some configurations are not known in advance and they should be set at deployment time via environment variables.

One such configuration is the credentials used to call the service broker. These are provided via the environment variable *SBF_BROKER_CREDENTIALS*. Here you can use arbitrary credentials. Just make sure to use the same credentials when you register the broker and don't commit these in source control.

Another deploy-time configuration is the service URL. It can be provided via the environment variable *SBF_SERVICE_CONFIG*. See [Additional Service Configuration](#additional-service-configuration) for details.

#### Push the broker application
Push the broker application to Cloud Foundry with the following command:
```sh
cf push
```
By default Cloud Foundry uses the application name for the host name. If this name is already taken, you can specify a different host via the `host` property in the manifest. Alternatively you can use a random host with the following command:
```sh
cf push --random-route
```

#### Register the service broker
For productive use a service broker is [registered globally](https://docs.cloudfoundry.org/services/managing-service-brokers.html#register-broker) so it can be used throughout Cloud Foundry, but this requires administrative permissions. During development and testing you can register the service broker only in your space. You do this with the following command:
```sh
cf create-service-broker my-broker-name broker-user broker-password <broker-url> --space-scoped
```
You can get the broker URL via command `cf apps`.
Here `my-broker-name` is an arbitrary name used to distinguish this service broker from the rest.
It is independent from the broker application name.

If you get an error like the following, another service broker uses the same service id or plan id.
```
Service broker catalog is invalid: Service ids must be unique
```
In this case you can either change the service name and the IDs in the catalog or add a suffix to make them unique:
```sh
cf create-service-broker my-broker-name broker-user broker-password <broker-url>/<unique-suffix> --space-scoped
```
Replace here `<unique-suffix>` with some unique string like your user name or space name.

#### Use the service broker
Now you can use your service broker within the same space.
For example you should see its services and plans via `cf marketplace` command.
You can use the new services as regular [services](https://docs.cloudfoundry.org/devguide/services/) in Cloud Foundry.
For example you can create a service instance via `cf create-service`.
Then bind it to your application via `cf bind-service`. After that the application will get the URL and the credentials for your service in the environment variable [VCAP_SERVICES](https://docs.cloudfoundry.org/devguide/deploy-apps/environment-variable.html).
You can see them via the `cf env` command.

You can also register the service broker in another space and use it there.
To do that append a unique suffix to the broker URL:
```sh
cf create-service-broker my-broker-name broker-user broker-password <broker-url>/<unique-suffix> --space-scoped
```
You should use a different suffix for each broker registration.

### Extend the service broker

Some service brokers need to perform custom actions during standard broker operations.
For example special actions might be necessary in order to provision a new service instance.
To do that, you can create a custom Node.js application for your service broker.
This application can use the service broker framework as a normal Node.js package.
Then you can register [custom callbacks](#hooks) to be invoked during each broker operation.

Create a Node.js application and add a _@sap/sbf_ dependency as described [above](#create-a-nodejs-application).

Create the start script of your broker application, e.g. _start.js_:
```js
const Broker = require('@sap/sbf');

let broker = new Broker({
  hooks: {
    onProvision: (params, callback) => {
      console.log('Provision service %s with plan %s', params.service_id, params.plan_id);
      // custom provision actions
      callback();
    },
    onDeprovision: (params, callback) => {
      console.log('Deprovision service instance %s', params.instance_id);
      // custom deprovision actions
      callback();
    }
  }
});
let server = broker.start();
```

Edit the _package.json_ file and set the `start` command to execute your start script:
```json
  "scripts": {
    "start": "node start.js"
  }
```

See [examples/node.js/custom-hooks](examples/node.js/custom-hooks) for a complete example.

### Asynchronous broker operations

By default service broker operations like provision and deprovision are synchronous,
i.e. HTTP response is returned when the operation is complete.
To allow for long running operations, some platforms like Cloud Foundry support also asynchronous operations.
See [Synchronous and Asynchronous Operations](https://github.com/openservicebrokerapi/servicebroker/blob/v2.13/spec.md#synchronous-and-asynchronous-operations)
in Open Service Broker API.

**Note:** currently the XS advanced runtime does not support asynchronous operations.

To perform an asynchronous operation you should implement several [hooks](#hooks).
First you should check if the platform supports asynchronous operations.
If this is the case, you can start the operation in the background and return `async: true` in the `reply`:
```js
function onProvision(params, callback) {
  if (params.accepts_incomplete !== 'true') {
    let error = new Error('Cannot provision service instance synchronously');
    error.statusCode = 422; // Unprocessable Entity
    return callback(error);
  }
  let operationId;
  // start the operation in the background ...
  // and assign operationId ...
  callback(null, {
    async: true, // indicate that operation was started asynchronously
    operation: operationId // later the same operationId will be passed to onLastOperation
  });
}
```
The same applies also to `onUpdate` and `onDeprovision` hooks.

Next the platform will start polling on regular intervals for the status of the operation.
Each time it will pass the same `operation` string to identify the operation.
This is useful if multiple asynchronous operations are running in parallel, e.g. multiple service instances are created at the same time.
To provide the current status of the operation, you should implement [`onLastOperation`](#onlastoperationparams-callback) hook:
```js
function onLastOperation(params, callback) {
  let operationId = params.operation; // for which operation to return status
  // get operation status ...
  callback(null, {
    state: 'in progress', // or 'succeeded' or 'failed'
    description: 'progress 50%' // Some user-facing message, what is going on
  });
}
```

**Note:** If several instances of the service broker are running, it is very likely that the start of an asynchronous operation and subsequent polling via [onLastOperation](#onlastoperationparams-callback) will be handled by different broker instances.
So make sure that all broker instances see the same state.

### Service broker as middleware
You can create a custom Node.js application and add the service broker as a middleware. The *Broker* class has property `app` which is an express application.
Example:
```javascript
const express = require('express');
const Broker = require('@sap/sbf');

let app = express();
let broker = new Broker();

app.get('/health', (req, res) => {
  res.send('OK');
});
app.use('/broker', broker.app);

app.listen(process.env.PORT);
```

Then to register the broker use url: `https://<app-url>/broker`.

### Custom parameters

Custom parameters can be passed to the service broker at several places.
The parameters are passed as a JSON object. It can have arbitrary content and is not interpreted by Cloud Foundry.

#### Create service with custom parameters

```sh
cf create-service <service> <plan> <service-instance> -c parameters.json
```
The content of _parameters.json_ is passed to the service broker and can be accessed in the [`onProvision`](#onprovisionparams-callback) hook via the `params.parameters` argument.

**Note**: When using XSUAA for authentication, the parameters JSON should contain `xs-security` property to avoid confusion with custom parameters.
See [XSUAA](#xsuaa) for details.

#### Update service with custom parameters

```sh
cf update-service <service-instance> -c parameters.json
```
The content of _parameters.json_ is passed to the service broker and can be accessed in [`onUpdate`](#onupdateparams-callback) hook via `params.parameters` argument.

#### Bind service with custom parameters

```sh
cf bind-service <application> <service-instance> -c parameters.json
```
The content of _parameters.json_ is passed to the service broker and can be accessed in [`onBind`](#onbindparams-callback) hook via `params.parameters` argument.

### Credentials providers

By default this module will search for a bound service instance which will generate credentials for the services, which the service broker offers. The framework will try to find a suitable service with the following properties in this order:
1. SAP HANA Service Instance (A service with label `hana` and plan `sbss`)
2. PostgreSQL Service Instance (A service with label `postgresql` and tag `sbss`)
3. XSUAA Service Instance (A service with label `xsuaa` and plan `broker`)

If no such service is found in the environment of the broker, an error is thrown.

This behavior can be disabled by [setting the credentials provider service explicitly](#credentials-provider-service).

Depending on the type of the credentials provider service - SBSS(for SAP HANA and PostgreSQL) or XSUAA, this module generates credentials and merges them in the `credentials` object of the response to *bind* operation.
The same object will appear also in the `credentials` section for the respective service in the `VCAP_SERVICES` environment variable in bound applications. You can find some examples below.

#### SBSS

SBSS (Service Broker Security Support) can generate, store and verify usernames and passwords in a secure way. It is accessed via the SQL API.

##### SBSS on SAP HANA

Create SBSS service instance (example):
```sh
cf create-service hana sbss hana-sbss
```
Here `hana-sbss` is an arbitrary service instance name.

Generated credentials example:
```json
{
  "username": "SBSS_00536748842276225491856140796794258250872406624126918117591330539",
  "password": "Aa_12905484905134285946159829260519429913717511989397057274381675342",
}
```

**Note**: Since version 4 of _@sap/sbf_, broker applications that use SBSS on HANA need to explicitly specify
a dependency to the _@sap/hdbext_ package.

##### SBSS on PostgreSQL

SBSS on PostgreSQL credentials provider requires 2 services to be bound to the service broker application. One is the actual PostrgeSQL service instance and additional user-provided service containing restricted DB user to be used for credentials generation.

Create SBSS service instance (example):
```sh
cf create-service postgresql v9.4-dev pg-sbss -t sbss
```
Here `pg-sbss` is an arbitrary service instance name. Notice that the command attaches the tag `sbss` to the service instance. **This tag is mandatory.** It can also be set after the service instance has been created like this:
```sh
cf update-service pg-sbss -t sbss
```

Create restricted DB user service (example):
```sh
cf create-user-provided-service sbss-configuration -p "{\"tag\":\"sbss-config\",\"restricted-dbuser-name\":\"<dbuser>\",\"restricted-dbuser-password\":\"<dbpassword>\"}"
```
Here you can use arbitrary values for `restricted-dbuser-name` and `restricted-dbuser-password`.
You should bind the same service instance to SBSS installer application when deploying SBSS on Postgres.
For details see the SBSS documentation.

**Note:** You should bind _both_ service instances to the service broker application.

#### XSUAA

Create xsuaa instance of plan _broker_ (example):
```sh
cf create-service xsuaa broker <service-instance> -c xs-security.json
```

Later on you can create instances of the reuse service like this:
```sh
cf create-service my-service my-plan <service-instance> -c parameters.json
```
Here we assume that service `my-service` with plan `my-plan` is defined in the service catalog of the broker.

*parameters.json*:
```
{
  "xs-security": {
    "xsappname": "my-app",
    ...
  },
  "customProperty1": 1,
  "customProperty2": "2",
  ...
}
```

`xs-security` object in *parameters.json* has the same structure as [xs-security.json] file.
It is sent to XSUAA to create an OAuth client for each instance of the reuse service.

`xs-security` properties can be overwritten by additional service configuration defined in the environment variable `SBF_SERVICE_CONFIG`.
See [Additional Service Configuration](#additional-service-configuration).

Other top level properties are optional (e.g. `customProperty1` and `customProperty2`) and can be used to pass arbitrary parameters.
The whole *parameters.json* file is accessible via `params.parameters` in [`onProvision(params, callback)`](#onprovisionparams-callback) hook.

**Note**: Updating the `xs-security` properties of the service instance is not supported. So `xs-security` property will be ignored by `cf update-service` command.

**Note**: Custom parameters can be defined as root level properties. If `xs-security` is not defined, the SBF will generate a default value, where `xsappname` is set to the service instance id.

Generated credentials example:
```json
{
  "uaa": {
    "clientid": "sb-my-app!b27|reuse-service!b27",
    "clientsecret": "o7M5UE0S+Q498j9zNmAlAKdYrSo=",
    "identityzone": "cc-sap",
    "tenantid": "cc-sap",
    "tenantmode": "dedicated",
    "uaadomain": "authentication.sap.hana.ondemand.com",
    "url": "https://cc-sap.authentication.sap.hana.ondemand.com",
    "verificationkey": "-----BEGIN PUBLIC KEY----- ... -----END PUBLIC KEY-----",
    "xsappname": "my-app!b27|reuse-service!b27"
  }
}
```
An application can use these credentials to call the UAA to fetch a proper JWT token. Then the application can call the reuse service using this token as authentication.

As it's seen the `clientid` and the `xsappname` properties hold some specific information. Here the string "my-app" corresponds to the _xsappname_ from the _security.json_ which was provided when creating the service instance which the service broker offers. The string "reuse-service" corresponds to the _xsappname_ in the _security.json_ which was used to create the xsuaa service instance with plan broker. More information can be found in the examples.

### Unique service broker

Normally for productive use a service broker is deployed once.
Then a Cloud Foundry administrator registers it globally and makes it visible to certain organizations.

Sometimes it is necessary to deploy the same broker with the same catalog multiple times,
e.g. during development or testing. Then you can hit some Cloud Foundry constraints.

These properties should be unique across Cloud Foundry:
- Service broker name (not used in the broker itself)
- Service broker URL
- Service name
- Service ID
- Plan ID

The service broker framework can append a suffix to each service name, ID and plan ID to make them unique.
There are 3 options to provide this suffix (taken in the following order):
1. append the suffix in the broker URL
```sh
cf create-service-broker broker-name user password https://broker.domain/suffix --space-scoped
```
2. broker's constructor option `catalogSuffix`
3. environment variable `SBF_CATALOG_SUFFIX`.

If this suffix is specified, it is used only in the communication with service broker clients like Cloud Controller.
Internally this suffix is removed, so all hook functions will get IDs without the suffix, just like in the service catalog.
Still in the marketplace the services will be visible with the suffix. So you will have to use the suffix in commands like `cf create-service`.

The URL suffix should not contain URL special characters (`/`, `?`, etc.).

Notice that the URL suffix allows you to register and use the same broker in multiple spaces, so you don't have to push it in each space.
Assume you have pushed a service broker application and its URL is https://my-broker.domain.com/.
Then you can register this broker in one space:
```sh
cf create-service-broker my-broker-abc user password https://my-broker.domain.com/abc --space-scoped
```
This will append the suffix "abc" to each service name, ID and plan ID in the catalog in this space.

You can also register the same broker in another space:
```sh
cf create-service-broker my-broker-xyz user password https://my-broker.domain.com/xyz --space-scoped
```
This will append the suffix "xyz" to each service name, ID and plan ID in the catalog in that space.

In this case the same service will be visible with different names in different spaces.

### Secure outgoing connections

By default all outgoing connections from the service broker must be encrypted or the broker will fail to start (this is not the case with SBSS connections).
This behavior can be changed using the `secureOutgoingConnections` option or the environment variable `SBF_SECURE_OUTGOING_CONNECTIONS`.
If one of them is set to *false*, unencrypted connections will be allowed.

**Note:** This option does not apply for connections made by custom code (for example: [`hooks`](#hooks)).

### Stateless

A service broker can and should be scaled to run with several instances to achieve high availability and if necessary handle more load.
For this reason the service broker framework is designed to be stateless.
So it maintains no state between broker requests and provides no communication among broker instances.
If custom hooks introduce some state, they should take care to synchronize it across multiple broker instances.

Special care should be taken for asynchronous operations which have inherent state.
It is very likely that the start of an asynchronous operation and subsequent polling via [onLastOperation](#onlastoperationparams-callback) will be handled by different broker instances.

### Memory usage

A non customized SBF application (without custom code) consumes around 52MB of memory in idle state.
During light load (less then 10 concurrent requests) the memory consumption is around 110MB (depending on the requests type).
During heavy load (100+ concurrent requests) the memory could reach 160MB.
Recommendations:
 * For light load scenarios, deploy with memory limit at least 128MB.
 * For heavy load scenarios, deploy with memory limit at least 256MB.

Also, consider scaling out the broker application with multiple instances.
This will increase both the throughput and the fault tolerance (against app crashes).

If custom code is used (e.g. hooks or middleware), its memory usage should be taken into account when calculating the overall memory consumption.

In addition you should limit the Node.js heap size accordingly.
The general recommendation is to set it to 75% of the application memory limit.
For example (in manifest.yml):
```
  memory: 128M
  env:
    NODE_OPTIONS: --max-old-space-size=96
```

### User Interface

The service broker framework provides no user interface.
It implements only the standard [Service Broker API](https://docs.cloudfoundry.org/services/api.html).

Still if your services provide a web-based management user interface, you can expose it via the `reply.dashboard_url` property in [`onProvision`](#onprovisionparams-callback) hook.

### Security
To ensure ISO/SOC compliance, certain security requirements should be fulfilled:
* Minimum password length of 15 characters (fulfilled by passwords generated by SBSS, XSUAA and deploy service)
* Regular password rotation

#### Password rotation
You can use this procedure to update the broker password without downtime.
1. Deploy the broker with the new password as a new application
2. Update the broker registration with the new password and URL
```sh
cf update-service-broker <broker-name> <broker-username> <broker-password> <broker-url>
```
3. Delete the old broker application

#### HTTPS
Since different credentials are transferred between the service broker and its client (Cloud Controller),
the communication should be encrypted. If the broker is deployed as an application in Cloud Foundry,
no special configuration is required as the platform provides HTTPS support.
If the broker is deployed outside the platform then HTTPS should be enabled.
This section describes how to do that.

Create a custom start script, for example _broker.js_:
```javascript
const https = require('https');
const fs = require('fs');
const Broker = require('@sap/sbf');

const broker = new Broker();

// this is an example, you should provide your own key and certificate
const options = {
  key: fs.readFileSync('server-key.pem'),
  cert: fs.readFileSync('server-cert.pem')
};

https.createServer(options, broker.app).listen(process.env.PORT);
```
For details how to configure HTTPS see [https.createServer](https://nodejs.org/api/https.html#https_https_createserver_options_requestlistener).

Use your start script in the `start` command in _package.json_
```json
  "scripts": {
    "start": "node broker.js"
  }
```

### Audit logging

_@sap/sbf_ writes to audit log for every operation except for _catalog_
(an instance of the Audit log service should be bound to the broker).
The user is taken from the first of the following that contains a valid value:
- `X-Broker-API-Originating-Identity` header (if provided), property `user_id` (in case running on Cloud Foundry).
- `X-Broker-API-Originating-Identity` header (if provided), property `uid` (in case running on Kubernetes).
- `X-Broker-API-Originating-Identity` header (if provided), property `username` (in case running on Kubernetes).
- The authenticated user that calls the service broker.

It is recommended to use the same user in hooks that also write audit messages.
What the `X-Broker-API-Originating-Identity` header contains (if present) can be found
in the `originating_identity` property of the `params` object passed to the hook.
If `originating_identity` is not available, then the `user_id` property can be used.
It contains the authenticated user that called the broker.

## Reference

### Class: ServiceBroker
Service broker class.

#### new ServiceBroker([options])
Creates a new ServiceBroker instance.

* `options` *Object* Optional parameter containing the following properties:
  * [`brokerCredentials`](#service-broker-credentials) *Object* The credentials for calling the service broker, if using the plain text format.
  * [`brokerCredentialsHash`](#service-broker-hashed-credentials) *Object* The credentials for calling the service broker, if using the hashed format.
  * [`catalog`](#service-catalog) *String|Object* This property holds the service catalog. If it is a *String*, it should be a path to a JSON file which contains the catalog information.
  * [`serviceConfig`](#additional-service-configuration) *Object* Provides additional deploy-time configuration to extend the service catalog.
  * [`hooks`](#hooks) *Object* Contains callback functions that can extend or customize service broker operations.
  * [`autoCredentials`](#automatic-credentials-generation) *Boolean* Enable automatic credentials generation.
  * [`credentialsProviderService`](#credentials-provider-service) *String* The name of the credentials provider service instance.
  * [`sbssRestrictedUserService`](#credentials-provider-service) *String* The name of the service containing SBSS restricted user credentials.
  * [`catalogSuffix`](#unique-service-broker) *String* Suffix which will be appended to each service name, ID and plan ID in the service catalog to make them unique across Cloud Foundry.
  * `enableAuditLog` *Boolean* Enable/Disable audit logging. Defaults to **true**.
  * [`secureOutgoingConnections`](#secure-outgoing-connections) *Boolean* If *false*, unencrypted outgoing connections will be allowed. Defaults to **true**.

#### ServiceBroker.start()
Starts the service broker.

* _returns_ the [http.Server](https://nodejs.org/api/http.html#http_class_http_server) used by the service broker

You can attach handlers for 'error' and 'listening' events like this:
```js
let broker = new ServiceBroker(options);
let server = broker.start();
server.on('error', err => console.error(err));
server.on('listening', () => console.log('Listening'));
```

#### ServiceBroker.app
Express application which you can use as a middleware. See [Service broker as middleware](#service-broker-as-middleware).

#### ServiceBroker.callXsuaa(req, options, callback)
Utility function to easily make HTTP calls to XSUAA. Authentication to XSUAA is performed internally.

* `req` *Object* Details can be found [here](#req).
* `options` *Object* Parameter containing the following properties:
  * `path` *String* XSUAA REST API endpoint. This path will be appended to the XSUAA base URL internally.
  * The [options](https://github.com/request/request#requestoptions-callback) described in the documentation of the [request](https://www.npmjs.com/package/request) package.
* `callback` *function(error, res, body)*
  * The [parameters](https://github.com/request/request#requestoptions-callback) described in the documentation of the [request](https://www.npmjs.com/package/request) package.

Example:
```js
const Broker = require('@sap/sbf');

let broker = new Broker({
  hooks: {
    onProvision: (params, callback) => {
      const encodedInstanceId = encodeURIComponent(params['instance_id']);
      let options = {
        path: `/sap/rest/broker/clones/${encodedInstanceId}/binding`,
        method: 'GET'
      };
      broker.callXsuaa(params.req, options, (err, res, body) => {
        if (err) { return callback(err); }

        if (res.statusCode !== 200) {
          return callback(new Error(`Status code: ${res.statusCode}. Body: ${body}`));
        }

        try {
          const credentials = JSON.parse(body);
          console.log('XSUAA clone credentials:', credentials);
          callback();
        } catch (err) {
          callback(new Error(`Failed to parse UAA response with status code ${res.statusCode} and body ${body}`));
        }
      });
    }
  }
});
let server = broker.start();
```

#### (static) ServiceBroker.createCredentialsProvider(credentials)

Creates a suitable [credentials provider](#credentials-providers) instance according to the passed `credentials`.
Disabling [automatic credentials generation](#automatic-credentials-generation) and manually creating a credentials provider allows using multiple providers in the same broker and brings more flexibility when extending the broker with custom code.

**Note**: This approach requires implementing the relevant hooks (`onProvision`, `onBind`, `onUnbind` and `onDeprovision`) and calling the respective method on the created provider.

* `credentials` *Object* Credentials for a UAA or an SBSS service.

**Note**: If using SBSS on PostgreSQL, the restricted user properties should be provided in the `restrictedUser` property of `credentials`. Example:

```js
const credentials = xsenv.cfServiceCredentials('postgre-service-name');
credentials.restrictedUser = xsenv.cfServiceCredentials('restricted-user-service-name');
const provider = Broker.createCredentialsProvider(credentials);
```

* Returns a [credentials provider](#credentials-providers) instance.

A credentials provider has the following methods:

* `provision(req, callback)`
Performs operations associated with service provisioning.
  * `req` *Object* Details can be found [here](#req).
  * `callback` *function(error)* An error is received in the callback in case of operations' failure.

* `bind(req, callback)`
Performs operations associated with service binding.
  * `req` *Object* Details can be found [here](#req).
  * `callback` *function(error, credentials)* An error is received in the callback in case of operations' failure. `credentials` is an object containing the generated credentials.

* `unbind(req, callback)`
Performs operations associated with service unbinding.
  * `req` *Object* Details can be found [here](#req).
  * `callback` *function(error)* An error is received in the callback in case of operations' failure.

* `deprovision(req, callback)`
Performs operations associated with service deprovisioning.
  * `req` *Object* Details can be found [here](#req).
  * `callback` *function(error)* An error is received in the callback in case of operations' failure.

In addition, a UAA credentials provider has the following method:

* `callXsuaa(req, options, callback)`
See [this section](#servicebrokercallxsuaareq-options-callback) for more information.

Example:

```js
const Broker = require('@sap/sbf');

// Applications can have a single provider:
// const provider = Broker.createCredentialsProvider({ /* ... */ })

// or multiple providers, shown below

let broker = new Broker({
  autoCredentials: false,
  hooks: {
    onProvision: (params, callback) => {
      // validate request's params
      const provider = Broker.createCredentialsProvider({ /* ... */ });
      provider.provision(params.req, callback);
    },
    onBind: (params, callback) => {
      const provider = Broker.createCredentialsProvider({ /* ... */ });
      provider.bind(params.req, (err, credentials) => {
        if (err) { return callback(err); }
        credentials.url = '...';
        callback(null, { credentials });
      });
    },
    onUnbind: (params, callback) => {
      const provider = Broker.createCredentialsProvider({ /* ... */ });
      provider.unbind(params.req, callback);
    },
    onDeprovision: (params, callback) => {
      const provider = Broker.createCredentialsProvider({ /* ... */ });
      provider.deprovision(params.req, callback);
    }
  }
});
let server = broker.start();
```

**Note**: Provision and bind are operations associated with creating a resource in the service used for credentials generation. If an error has occurred in a hook after the respective provider method has been called (i.e. `provider.provision` and `provider.bind`), it is recommended that hooks also call the opposite method (i.e. `provider.deprovision` and `provider.unbind`) to clean up the already created resources.

### Service Broker Credentials
Credentials in plain text format used by the Cloud Controller and other clients to call the service broker.
It is an object where each key is a user name and the value is the respective password. It may contain multiple credentials but at least one is required.

Example:
```json
{
  "user1": "password1",
  "user2": "password2"
}
```

These credentials can be provided via the option `brokerCredentials` or the environment variable `SBF_BROKER_CREDENTIALS`.

**Note:** Service broker credentials must be provided either in plain text or [hashed](#service-broker-hashed-credentials) format. The service broker will not work if credentials in neither or both formats are present.

### Service Broker Hashed Credentials
Credentials in hashed format used by the Cloud Controller and other clients to call the service broker.
It is an object where each key is a user name and the value is the respective password in format `sha256:<salt>:<hash-digest-of-salt+password>`.
Here `<salt>` and `<hash-digest-of-salt+password>` are _base64_-encoded strings.
It may contain multiple credentials but at least one is required.

Example:
```json
{
  "user1": "sha256:gVJILqx/97j4aWVQas5RbSUFpWzu7OpaHOt0O29CJOc=:4klnhxFY2YYwzHO7unYu7jc+HuikQLhF7Ebk8tjOJ9c=",
  "user2": "sha256:0NRIb4Gzx1zFRTTs6qpElujmHuUE1TAIg3NbES219f0=:Gv1NMeIzxlbmOCLvY3q4DMbiDXamqF3xRfFivUdligo="
}
```

These credentials can be provided via the option `brokerCredentialsHash` or the environment variable `SBF_BROKER_CREDENTIALS_HASH`.

**Note:** Service broker credentials must be provided either in [plain text](#service-broker-credentials) or hashed format. The service broker will not work if credentials in neither or both formats are present.

**Note:** To generate such hashed credentials, you can use the [hash-broker-password](#hash-broker-password) script.

### Service Catalog
This is a JSON object describing all services and plans offered by this service broker. Its structure is described in [Catalog Management](https://docs.cloudfoundry.org/services/api.html#catalog-management) in Cloud Foundry documentation.

By default the service catalog is loaded from *./catalog.json* file. Alternatively, the catalog file could be explicitly set via the `SBF_CATALOG_FILE` environment variable.

**Note:** Each service name, ID and plan ID in the catalog must be unique across Cloud Foundry.
GUIDs are recommended for service ID and plan ID.
See [Unique service broker](#unique-service-broker).

**Warnings for broker authors:**
- Be cautious when removing services and plans from their catalogs, as platform marketplaces might have provisioned service instances of these plans. Consider your deprecation strategy.
- Do not change the IDs of services and plans. This action is likely to be evaluated by a platform marketplace as a removal of one plan and addition of another. See above warning about removal of plans.

**Note:** For the service image to display correctly in the cockpit it should be encoded as Base64 in the property `metadata.imageUrl` instead of a URL.

Service catalog example:
```json
{
  "services": [{
    "name": "fake-service",
    "id": "acb56d7c-XXXX-XXXX-XXXX-feb140a59a66",
    "description": "fake service",
    "tags": ["no-sql", "relational"],
    "requires": ["route_forwarding"],
    "bindable": true,
    "metadata": {
      "provider": {
        "name": "The name"
      },
      "listing": {
        "imageUrl": "http://example.com/cat.gif",
        "blurb": "Add a blurb here",
        "longDescription": "A long time ago, in a galaxy far far away..."
      },
      "displayName": "The Fake Broker"
    },
    "dashboard_client": {
      "id": "398e2f8e-XXXX-XXXX-XXXX-19a71ecbcf64",
      "secret": "277cabb0-XXXX-XXXX-XXXX-7822c0a90e5d",
      "redirect_uri": "http://localhost:1234"
    },
    "plan_updateable": true,
    "plans": [{
      "name": "fake-plan-1",
      "id": "d3031751-XXXX-XXXX-XXXX-a42377d3320e",
      "description": "Shared fake Server, 5tb persistent disk, 40 max concurrent connections",
      "max_storage_tb": 5,
      "metadata": {
        "costs":[
            {
               "amount":{
                  "usd":99.0
               },
               "unit":"MONTHLY"
            },
            {
               "amount":{
                  "usd":0.99
               },
               "unit":"1GB of messages over 20GB"
            }
         ],
        "bullets": [
            "Shared fake server",
            "5 TB storage",
            "40 concurrent connections"
        ],
      }
    }, {
      "name": "fake-plan-2",
      "id": "0f4008b5-XXXX-XXXX-XXXX-dace631cd648",
      "description": "Shared fake Server, 5tb persistent disk, 40 max concurrent connections. 100 async",
      "max_storage_tb": 5,
      "metadata": {
        "costs":[
            {
               "amount":{
                  "usd":199.0
               },
               "unit":"MONTHLY"
            },
            {
               "amount":{
                  "usd":0.99
               },
               "unit":"1GB of messages over 20GB"
            }
         ],
        "bullets": [
          "40 concurrent connections"
        ]
      }
    }]
  }]
}
```

### Additional Service Configuration
This is a JSON object that provides additional deploy-time configuration.
Usually this is used for configurations which are not known in advance like URLs.
Each key in this object should match a service `name` in the catalog. Its value should be an object with the following optional properties:
* `extend_credentials` An object, containing these optional properties.
  * `shared` An object that is merged with the `credentials` object returned by the *bind* operation for this service.
  * `per_plan` An object where each key should match a plan of this service. The value is an object that is merged with the `credentials` object returned by the *bind* operation for this service and plan.
  Overrides any common properties in `shared` object.
* `extend_xssecurity` An object, containing these optional properties.
  * `shared` An object that will overwrite the properties that are sent to the XSUAA on service instance creation. It should have the same structure as [xs-security.json].
  * `per_plan` An object where each key should match a plan of this service. The value is an object that overwrites the properties that are sent to XSUAA when a service instance of this plan is created. This object should have the same structure as [xs-security.json].
  Overrides any common properties in `shared` object.
* `extend_catalog` An object that is merged with the object describing this service in the catalog.

All of these properties are optional.

This configuration can be provided via the option `serviceConfig` or the environment variable `SBF_SERVICE_CONFIG`.

Example:
```js
{
  "service1": {
    "extend_credentials": {
      "shared": {
        // This will go into credentials when binding
        // Common properties for all plans
      },
      "per_plan": {
        "plan1": {
          // Properties specific to this plan
          // This will be merged with "shared" and will go to credentials when binding
        },
        "plan2": {
          "uri": "http://some.host/plan2"
        }
      }
    },
    "extend_xssecurity": {
      "shared": {
        // This object will extend the properties that are sent to the XSUAA on service instance creation
        // Common properties for all plans
        "authorities": ["$XSMASTERAPPNAME.shared_limited_scope"]
      },
      "per_plan": {
        "plan1": {
          // This object will extend the properties that are sent to the XSUAA on service instance creation
          // This will overwrite "shared" properties
          "authorities": ["$XSMASTERAPPNAME.plan_limited_scope"]
        }
      }
    },
    "extend_catalog": {
      // Will hold free-form JSON that will be merged with the catalog description for service "service1"
      "dashboard_client": {
        "id": "133423",
        "secret": "secret",
        "redirect_uri": "http://some.host/dashboard"
      },
      "metadata": {
        "documentationUrl": "http://vendor.com/docs",
        "supportUrl": "http://vendor.com/support"
      }
    }
  }
}
```

### Automatic Credentials Generation
By default this module will try to find a suitable credentials provider service using the strategies described [here](#credentials-providers).

This behavior can be disabled via the `autoCredentials` option so you can take full control of credentials generation in your code.
In this case the `onBind` hook must be implemented as it is responsible for providing the credentials in the reply.

**Note:** To ensure consistent security, it is highly recommended that applications and services use security features provided by the platform instead of implementing their own.

### Credentials Provider Service

It is possible to explicitly specify the credentials provider service name when [automatic credentials generation](#automatic-credentials-generation) is enabled. This could be achieved via the `credentialsProviderService` option or via the environment variable `SBF_CREDENTIALS_PROVIDER_SERVICE`.

The same applies for providing restricted user credentials (SBSS on PostgreSQL case) where the service name can be provided via the `sbssRestrictedUserService` option or via the environment variable `SBF_SBSS_RESTRICTED_USER_SERVICE`.

### Business Service Support

SBF will automatically add the following properties to the credentials returned in the response to a bind request:
* `html5-apps-repo` object containing `app_host_id` property
* `sap.cloud.service`
* `saasregistryenabled`

**Note:** In order to provide the `html5-apps-repo` as part of the service credentials, the service broker must be bound to exactly one *html5-apps-repo* service instance (*app-host* plan).
**Note:** It is expected that the `sap.cloud.service` and the `saasregistryenabled` properties are defined in the service catalog, under the `sapservice` property of the service metadata, for example:
```json
{
  "services": [{
    "name": "fake-service",
    "id": "acb56d7c-XXXX-XXXX-XXXX-feb140a59a66",
    "description": "fake service",
    "tags": ["no-sql", "relational"],
    "bindable": true,
    "metadata": {
      "sapservice": {
        "sap.cloud.service": "com.sap.sbf.testservice",
        "saasregistryenabled": true
      }
    },
    "plan_updateable": true,
    "plans": [{
      "name": "fake-plan-1",
      "id": "d3031751-XXXX-XXXX-XXXX-a42377d3320e",
      "description": "Shared fake Server, 5tb persistent disk, 40 max concurrent connections",
      "max_storage_tb": 5,
    }]
  }]
}
```

### Hooks
Hooks are custom callback functions that allow you to extend and even replace default service broker functionality.
There is a hook for each service broker operation (except for *catalog*).

#### `onProvision(params, callback)`
Called when the broker receives a *provision* request.

* `params` *Object*
  * `instance_id` *String* Service instance ID
  * `originating_identity` *Object* Only available if the `X-Broker-API-Originating-Identity` header is provided in the request.
  Contains the parsed data from the header (more information about the structure can be found [here](https://github.com/openservicebrokerapi/servicebroker/blob/v2.13/profile.md#originating-identity-header)).
  * `user_id` *String* The authenticated user that called the broker.
  * `req` *Object* Details can be found [here](#req).
  * The parameters described in the OSB API specification under [Provisioning, Parameters](https://github.com/openservicebrokerapi/servicebroker/blob/v2.13/spec.md#parameters-1)
  * The fields described in the OSB API specification under [Provisioning, Body](https://github.com/openservicebrokerapi/servicebroker/blob/v2.13/spec.md#body-2)
* `callback` *function(error, reply)*
  * `error` *Object* See [Error handling](#error-handling).
  * `reply` *Object* An object returned as a response to the *provision* request.
    * `async` *Boolean* (Optional) Specifies whether the provision operation is started asynchronously. Default is `false`. It will not be included in the response.
    * `dashboard_url` *String* (Optional) The URL of a web-based management user interface for the service instance; we refer to this as a service dashboard. The URL MUST contain enough information for the dashboard to identify the resource being accessed. **Note:** a broker that wishes to return *dashboard_url* for a service instance MUST return it with the initial response to the provision request, even if the service is provisioned asynchronously.
    * `operation` *String* (Optional) For asynchronous responses, service brokers MAY return an identifier representing the operation. The value of this field SHOULD be provided by the broker client with requests to the Last Operation endpoint in a URL encoded query parameter.

This hook is called _after_ the default SBF operation. For example, if XSUAA is used, the OAuth client clone is already created.

#### `onUpdate(params, callback)`
Called when the broker receives an *update* request.

* `params` *Object*
  * `instance_id` *String* Service instance ID
  * `originating_identity` *Object* Only available if the `X-Broker-API-Originating-Identity` header is provided in the request.
  Contains the parsed data from the header (more information about the structure can be found [here](https://github.com/openservicebrokerapi/servicebroker/blob/v2.13/profile.md#originating-identity-header)).
  * `user_id` *String* The authenticated user that called the broker.
  * `req` *Object* Details can be found [here](#req).
  * The parameters described in the OSB API specification under [Updating a Service Instance, Parameters](https://github.com/openservicebrokerapi/servicebroker/blob/v2.13/spec.md#parameters-2)
  * The fields described in the OSB API specification under [Updating a Service Instance, Body](https://github.com/openservicebrokerapi/servicebroker/blob/v2.13/spec.md#body-4)
* `callback` *function(error, reply)*
  * `error` *Object* See [Error handling](#error-handling).
  * `reply` *Object* An object returned as a response to the *update* request.
    * `async` *Boolean* (Optional) Specifies whether the update operation is started asynchronously. Default is `false`. It will not be included in the response.
    * `operation` *String* (Optional) For asynchronous responses, service brokers MAY return an identifier representing the operation. The value of this field SHOULD be provided by the broker client with requests to the Last Operation endpoint in a URL encoded query parameter.

SBF performs no additional processing for this operation.

#### `onDeprovision(params, callback)`
Called when the broker receives a *deprovision* request.

* `params` *Object*
  * `instance_id` *String* Service instance ID
  * `originating_identity` *Object* Only available if the `X-Broker-API-Originating-Identity` header is provided in the request.
  Contains the parsed data from the header (more information about the structure can be found [here](https://github.com/openservicebrokerapi/servicebroker/blob/v2.13/profile.md#originating-identity-header)).
  * `user_id` *String* The authenticated user that called the broker.
  * `req` *Object* Details can be found [here](#req).
  * The parameters described in the OSB API specification under [Deprovisioning, Parameters](https://github.com/openservicebrokerapi/servicebroker/blob/v2.13/spec.md#parameters-4)
* `callback` *function(error, reply)*
  * `error` *Object* See [Error handling](#error-handling).
  * `reply` *Object* An object returned as a response to the *deprovision* request.
    * `async` *Boolean* (Optional) Specifies whether the deprovision operation is started asynchronously. Default is `false`. It will not be included in the response.
    * `operation` *String* (Optional) For asynchronous responses, service brokers MAY return an identifier representing the operation. The value of this field SHOULD be provided by the broker client with requests to the Last Operation endpoint in a URL encoded query parameter.

This hook is called _before_ the default SBF operation. For example, if XSUAA is used, the OAuth client clone is not deleted yet.

**Note:** This hook should be repeatable (idempotent), i.e. if it completes successfully once, any subsequent invocations with the same parameters should be successful too. This is necessary in case the default SBF operation fails. Then it should be possible to repeat the whole operation to complete the cleanup. Also the platform may execute _deprovision_ after a failed _provision_ operation as part of [orphan mitigation](https://github.com/openservicebrokerapi/servicebroker/blob/master/spec.md#orphans). So `onDeprovision` hook may be called even when the service instance and associated resources do not exist.

#### `onLastOperation(params, callback)`
Called when the broker receives a *last operation* request.

* `params` *Object*
  * `instance_id` *String* Service instance ID
  * `originating_identity` *Object* Only available if the `X-Broker-API-Originating-Identity` header is provided in the request.
  Contains the parsed data from the header (more information about the structure can be found [here](https://github.com/openservicebrokerapi/servicebroker/blob/v2.13/profile.md#originating-identity-header)).
  * `user_id` *String* The authenticated user that called the broker.
  * `req` *Object* Details can be found [here](#req).
  * The parameters described in the OSB API specification under [Polling Last Operation, Parameters](https://github.com/openservicebrokerapi/servicebroker/blob/v2.13/spec.md#parameters)
* `callback` *function(error, reply)*
  * `error` *Object* See [Error handling](#error-handling).
  * `reply` *Object* An object returned as a response to the *last operation* request.
    * `state` *String* Valid values are "in progress", "succeeded", and "failed". While "state": "in progress", the platform SHOULD continue polling. A response with "state": "succeeded" or "state": "failed" MUST cause the platform to cease polling.
    * `description` *String* (Optional) A user-facing message displayed to the platform API client. Can be used to tell the user details about the status of the operation.

**Note:** Implementing `onLastOperation` is mandatory, if any other operation hook returns `reply.async = true`. If this hook is not implemented, SBF will return status 501 (Not Implemented).

See [Asynchronous broker operations](#asynchronous-broker-operations) for more information.

#### `onBind(params, callback)`
Called when the broker receives a *bind* request.

* `params` *Object*
  * `instance_id` *String* Service instance ID
  * `binding_id` *String* Service binding ID. It will be used for future unbind requests, so the broker will use it to correlate the resource it creates.
  * `originating_identity` *Object* Only available if the `X-Broker-API-Originating-Identity` header is provided in the request.
  Contains the parsed data from the header (more information about the structure can be found [here](https://github.com/openservicebrokerapi/servicebroker/blob/v2.13/profile.md#originating-identity-header)).
  * `user_id` *String* The authenticated user that called the broker.
  * `generatedCredentials` *Object* (Optional) The credentials object generated by the [credentials provider](#credentials-providers). It is not provided if the `autoCredentials` option is `false`.
  * `req` *Object* Details can be found [here](#req).
  * The fields described in the OSB API specification under [Binding, Body](https://github.com/openservicebrokerapi/servicebroker/blob/v2.13/spec.md#body-6)
* `callback` *function(error, reply)*
  * `error` *Object* See [Error handling](#error-handling).
  * `reply` *Object* An object returned as a response to the *bind* request.
    * `credentials` *Object* A free-form object of credentials that can be used by applications or users to access the service.

The `credentials` object in the response will be produced by merging:
1. `reply.credentials` returned from `onBind`
2. Credentials generated by the [Credentials Provider Service](#credentials-provider-service), unless [disabled](#automatic-credentials-generation)
3. The properties described in the [Business Service Support](#business-service-support) section
4. Binding properties for the given service and plan from [Additional Service Configuration](#additional-service-configuration)

Here each object overwrites common properties in the next one.

This hook is called _after_ the default SBF operation. For example, if SBSS is used, the binding credentials are already created.

**Note:** Implementing `onBind` hook is mandatory, if `autoCredentials` option is `false`.
In this case `onBind` must provide the necessary credentials in `reply.credentials`.

#### `onUnbind(params, callback)`
Called when the broker receives an *unbind* request.

* `params` *Object*
  * `instance_id` *String* Service instance ID
  * `binding_id` *String* Service binding ID. It will be used for future unbind requests, so the broker will use it to correlate the resource it creates.
  * `originating_identity` *Object* Only available if the `X-Broker-API-Originating-Identity` header is provided in the request.
  Contains the parsed data from the header (more information about the structure can be found [here](https://github.com/openservicebrokerapi/servicebroker/blob/v2.13/profile.md#originating-identity-header)).
  * `user_id` *String* The authenticated user that called the broker.
  * `req` *Object* Details can be found [here](#req).
  * The parameters described in the OSB API specification under [Unbinding, Parameters](https://github.com/openservicebrokerapi/servicebroker/blob/v2.13/spec.md#parameters-3)
* `callback` *function(error, reply)*
  * `error` *Object* See [Error handling](#error-handling).
  * `reply` *Object* An object returned as a response to the *unbind* request.

This hook is called _before_ the default SBF operation. For example, if SBSS is used, the binding credentials are not deleted yet.

**Note:** This hook should be repeatable (idempotent), i.e. if it completes successfully once, any subsequent invocations with the same parameters should be successful too. This is necessary in case the default SBF operation fails. Then it should be possible to repeat the whole operation to complete the cleanup. Also the platform may execute _unbind_ after a failed _bind_ operation as part of [orphan mitigation](https://github.com/openservicebrokerapi/servicebroker/blob/master/spec.md#orphans). So `onUnbind` hook may be called even when the service binding and associated resources do not exist.

#### `params` details

##### `req`

An [IncommingMessage](https://nodejs.org/api/http.html#http_class_http_incomingmessage) instance with additional properties:
- `loggingContext` - attached to the request object by the _@sap/logging_ library, provides means of getting loggers and tracers. The `correlationId` property provided by the `loggingContext` can be used to correlate log entries from different components involved in a broker operation. More information is available in the documentation of the _@sap/logging_ package.

#### Error handling
The `callback` function passed to each hook takes an `error` as its first argument.
This is the standard conventions for callback functions in Node.js.

**Note:** The hook must call the `callback` _exactly_ once.

In case of success, the hook should pass `null` or `undefined` as `error` argument to the `callback`.

In case of error, the hook should pass an [Error](https://nodejs.org/api/errors.html#errors_class_error) object as `error` argument to the `callback`. In this case any subsequent arguments will be ignored.

If the `error.statusCode` is set, it will be returned as HTTP status code in the response.
In this case the error message will be sent to the broker client.
Otherwise the broker will return HTTP status code 500 with a generic error message.

### Environment variables

- `SBF_CATALOG_FILE` - path to a catalog file, the default is *./catalog.json*, see [Service Catalog](#service-catalog)
- `SBF_CATALOG_SUFFIX` - suffix to append to all service names, service IDs and plan IDs in the catalog, see [Unique service broker](#unique-service-broker)
- `SBF_BROKER_CREDENTIALS` - JSON object with credentials in plain text format for calling the service broker, see [Service Broker Credentials](#service-broker-credentials)
- `SBF_BROKER_CREDENTIALS_HASH` - JSON object with credentials in hashed format for calling the service broker, see [Service Broker Hashed Credentials](#service-broker-hashed-credentials)
- `SBF_SERVICE_CONFIG` - provides additional deploy-time configuration, see [Additional service configuration](#additional-service-configuration)
- `SBF_CREDENTIALS_PROVIDER_SERVICE` - the name of the credentials provider service instance, see [Credentials provider service](#credentials-provider-service)
- `SBF_SBSS_RESTRICTED_USER_SERVICE` - the name of the service containing restricted user credentials (SBSS on PostgreSQL case), see [Credentials provider service](#credentials-provider-service)
- `SBF_UAA_TIMEOUT` - timeout in milliseconds for requests to XSUAA, default is 20 seconds.
- `SBF_SECURE_OUTGOING_CONNECTIONS` - if `false`, unencrypted outgoing connections will be allowed, see [Secure outgoing connections](#secure-outgoing-connections)
- `SBF_ENABLE_AUDITLOG` - if `false` disable audit logging, otherwise it is enabled.
- `PORT` - the port on which the service broker will listen for requests, default is 8080.

### `gen-catalog-ids`

Each service object and each service plan object has a mandatory _id_ field. Its value must be a non-empty string, globally unique within the platform marketplace. Using a GUID is recommended.

The _@sap/sbf_ package provides the `gen-catalog-ids` script which generates such GUIDs for you.

```sh
node_modules/.bin/gen-catalog-ids [<path-to-catalog.json>]
```
Here the file path argument is optional. If not provided, the command will use _catalog.json_ in the current directory.
This command will insert a new GUID as _id_ property for each service and each plan in the catalog.
It will not change any existing IDs - only the id properties with empty string for their value and the ones not provided at all.
You can run it after creating a new catalog or after adding more services or plans.

**Note:** In the command above you may need to replace the forward slashes with backslashes, depending on your platform.

### `hash-broker-password`

If you use service broker credentials in [hashed format](#service-broker-hashed-credentials), you will need to hash your plain text password. For this purpose the _@sap/sbf_ package provides the `hash-broker-passsword` script which does that for you.

If you want to use some password of your own, run:

```sh
node_modules/.bin/hash-broker-password
```

You will be prompted to enter the plaintext password and will be given its hash in format `sha256:<salt>:<hash-digest-of-salt+password>`.
Here `<salt>` is also generated by the script.

Otherwise you can use the command in _batch_ mode:

```sh
node_modules/.bin/hash-broker-password -b
```

That will generate a random 32-character plaintext password, random 32-byte salt and print them along with the hash.
Take note of the generated password and hash as they will not be persisted.

When you have your service broker hashed credentials generated, you should:
* provide hashed credentials via the option `brokerCredentialsHash` or the environment variable `SBF_BROKER_CREDENTIALS_HASH`
* provide the user and plaintext password when [registering the service broker](#register-the-service-broker).

## Troubleshooting

### Increase the log level

The service broker framework uses _@sap/logging_ package so all of its features are available to control logging.
For example to set all logging and tracing to finest level set `XS_APP_LOG_LEVEL` environment variable to `debug`.
See _@sap/logging_ documentation for details.

Some of the libraries used by this package employ other tracing mechanisms. For example many use the popular [debug](https://www.npmjs.com/package/debug) package. This means that by setting `DEBUG` environment variable, you can enable additional traces. Set it to `*` to enable all of them, but be careful as the output may be overwhelming.
In addition, internal Node.js traces can be enabled via `NODE_DEBUG` environment variable. [This post](http://www.juliengilli.com/2013/05/26/Using-Node.js-NODE_DEBUG-for-fun-and-profit/) describes it in more detail.

**Warning:** Enabling some of these options may trace security sensitive data, so use with caution.

### @sap/sbf not found

If you get the following error during deployment
```
       npm ERR! 404 Not found : @sap/sbf
       npm ERR! 404
       npm ERR! 404  '@sap/sbf' is not in the npm registry.
```
Run `npm install` locally and make sure `node_modules` is not in *.cfignore* file.
Then push again your broker application.

If you get that error when you run `npm install` locally, make sure to configure the proper npm registry as described on the wiki of this project.

### Cannot execute start-broker script

The service broker may crash during startup on XS advanced with one of the following errors in the log:
```
exec: start-broker: not found
```
```
start-broker: cannot execute: Permission denied
```

There are two possible solutions:
* Set environment variable `ALWAYS_INSTALL` to `true` for the broker application
* Change the `start` script in _package.json_ like this:
```
"start": "node node_modules/@sap/sbf/sbf.js"
```

### Create service fails with "Client already exists"

If `create-service` operation fails with error "Client already exists", you are probably attempting to create a second service instance with the same *xsappname* in the parameters. Note that *xsappname* should be different for each service instance.


[xs-security.json]: https://help.sap.com/viewer/4505d0bdaf4948449b7f7379d24d0f0d/2.0.03/en-US/6d3ed64092f748cbac691abc5fe52985.html
